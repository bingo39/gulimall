线程池
===

## 创建线程池

+ 方式一： 使用`Executors`工具类
+ 方式二： 使用原生`new ThreadPoolExecutor`

### 线程池的七大参数

+ corePoolSize:  
  核心线程数；【线程池创建好以后就准备就绪的线程数量，就等待来接受异步任务去执行】
    + <font color=red>特点：</font>  
      一致存在，除非设置允许超时`allowCoreThreadTimeOut`
+ maximumPoolSize :  
  设置最大线程数量 【控制资源量】
+ keepAliveTime:  
  存活时间 【如果当前的线程数量大于core数量】释放空闲的线程（<font color=red>备注：</font>释放的线程：maximumPoolSize -
  corePoolSize）只要线程空闲大于指定的keepAliveTime
+ TimeUnit :  
  时间单位
+ BlockingQueue<Runnable> workQueue  
  阻塞队列。【如果任务有很多，就会将目前多的任务放在队列里面。直到线程有空闲，就会去队列里取新的任务进行】
+ threadFactory :  
  线程的创建工厂。
+ RejectedExecutionHander handler :
  如果队列满了，按照指定的拒绝策略拒绝执行任务

#### 参数执行顺序

运行流程：

1. 线程池创建，准备好 `corePoolSize`数量的核心线程，准备接受任务
2. 新的任务进来，用`corePoolSize`准备好的空间线程执行
    + `corePoolSize` 满了，就将再进行的任务放入阻塞队列`workQueue`中。空间的`corePoolSize`就会自己去阻塞队列获取任务执行
    + 阻塞队列满了，就直接开新线程执行，最大只能开到`maximumPoolSize`指定的数量
    + `maximumPoolSize` 都执行好了`maximumPoolSize`-`corePoolSize`数量空闲的线程就会在`keepAliveTime`指定的时间后自动销毁。最终保持到`corePoolSize`大小
    + 如果线程数量开到了`maximumPoolSize`的数量，还有新任务进来，就会使用`reject`指定的拒绝策略进行处理
3. 所有的线程创建都是由指定的factory创建

> 开发中使用线程池的好处
> + 降低资源的消耗
    >
+ 通过重复利用已经创建好的线程降低线程的创建和消耗的消耗
> + 提高响应速度
    >
+ 线程池中的线程数没有超过线程池的最大上限时，有的线程处于等待分配任务的状态，当任务来时无需创建新的线程就能执行
> + 提高线程的可管理性
    >
+ 线程池会根据当前系统特点对池内的线程进行优化处理，减少创建和销毁线程带来的系统开销。无限的创建和销毁线程不仅消耗系统资源，还降低系统的稳定性。

## CompletableFuture 异步编排

