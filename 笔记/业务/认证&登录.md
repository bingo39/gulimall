 认证 & 登录
==

## 环境配置

+ 创建auth-server模板管理认证功能

![创建auth-server模板](../image/ProjectImg/%E5%88%9B%E5%BB%BAauth-server%E6%A8%A1%E6%9D%BF.png)

![image-20230823222505762](../image/ProjectImg/%E5%88%9B%E5%BB%BAauth-server-2.png)

+ host代理域名auth.gulimall.com

+ 引入common模块

+ 放入nacos配置中心和注册中心中

+ 引入登录页面和注册页面【index.html，host修改，放静态资源到nginx中】

+ 网关配置

  ```yaml
  spring:
    cloud:
      gateway:
        routes:
  ## 认证中心服务，auth-server模块
          - id: auth-server
            uri: lb://gulimall-auth-server
              predicates:
                - Host=auth.gulimall.com
  ```

+ nginx配置
  nginx.conf

  ```she
  # 配置上游服务器
      upstream gulimall{
          server 192.168.31.107:88;
      }
  
      include /etc/nginx/conf.d/*.conf;
  }
  ```

  gulimall.conf

  ```shell
   location / {
          # 修改为gulimall请求的index.html页面【找到上游服务器，即getway】
          proxy_pass http://gulimall;
          # 设置host请求头的值
          proxy_set_header Host $host;
      }
  ```

  

## 业务功能

### 验证码功能

#### 倒计时器

**<font color=green>页面:</font>**

+ 建立发送按钮/标签

```html
<a id="sendCode"> 发送验证码 </a>
```

+ jquery语法

```js
//发送验证码
			$(function (){
				$("#sendCode").click(function (){
					//1.给指定手机发送验证码
					//2.启动倒计时功能
					if($(this).hasClass("disabled")){
                        //如果class属性是disable，不给予操作【防止多次点击导致读秒加快】
					}else{
						timeoutChangeStyle();
					}
				});
			});
//倒计时功能
var num=60;
function timeoutChangeStyle(){
   //jquery方法attr,设置标签class
   $("#sendCode").attr("class","disabled");   //倒计时期间无法再次点击【防止多次点击导致线程多了，读秒变快】
   if(num == 0){
      $("#sendCode").text("发送验证码");
      num = 60;
      $("#sendCode").attr("class","");
   }else{
      var str= num + "s 后再次发送";
      $("#sendCode").text(str);
      setTimeout("timeoutChangeStyle()",1000);
   }
   num --;
}
```

#### 发送/接受验证码

使用阿里云官网提供的短信服务接口

>  <font color=red>:exclamation:注意事项：</font>
>
> + 视频中的阿里云短信服务文档和实际中有时间出入，具体参考官方文档
> + 短信发送不能由前端发送，容易遭到截取，例如F12控制台查看。应该由后台发送验证码请求。 
>   +  [阿里云市场-短信验证码服务](https://market.aliyun.com/products/57124001/cmapi00037170.html?spm=5176.2020520132.101.4.435d7218BTWg9W#sku=yuncode31170000018)

+ 编写第三方服务

【所有的第三方服务提供统一由gulimall-third-party模块提供】

① 创建新类：SmsComponent.java

```java
/**
 * 认证&登录-验证码发送功能
 */

@ConfigurationProperties(prefix = "spring.cloud.alicloud.sms")    //与配置文件绑定
@Data
@Component
public class SmsComponent {

    private String host;
    private String path;
    private String method;
    private String appcode;
    private String templateId;

    public void sendSmsCode(String phoneNumber,String content){
        Map<String, String> headers = new HashMap<String, String>();
        //最后在header中的格式(中间是英文空格)为Authorization:APPCODE 83359fd73fe94948385f570e3c139105
        headers.put("Authorization", "APPCODE " + appcode);
        //根据API的要求，定义相对应的Content-Type
        //备注：所谓content-type即是postman的body的选项标签
        headers.put("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
        Map<String, String> querys = new HashMap<String, String>();
        Map<String, String> bodys = new HashMap<String, String>();
        bodys.put("content", content);
        bodys.put("template_id", templateId);
        bodys.put("phone_number", phoneNumber);


        try {
            /**
             * 重要提示如下:
             * HttpUtils请从
             * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/src/main/java/com/aliyun/api/gateway/demo/util/HttpUtils.java
             * 下载
             *
             * 相应的依赖请参照
             * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/pom.xml
             */
            HttpResponse response = HttpUtils.doPost(host, path, method, headers, querys, bodys);
            System.out.println(response.toString());
            //获取response的body
            //System.out.println(EntityUtils.toString(response.getEntity()));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

> 需要引入HttpUtils类。直接在config包下新建并且拷贝[HttpUtils.java](https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/src/main/java/com/aliyun/api/gateway/demo/util/HttpUtils.java)内容

配置文件关联上述private属性

```yaml
spring.cloud.sms:
  host: https://dfsns.market.alicloudapi.com
  path: /data/send_sms
  method: POST
  appcode: f8cedaeaaaf2455ebd275ddc248ad277
  templateId: CST_ptdie100
```

② 创建Controller接受

```java
@RestController
@RequestMapping("/sms")
public class SmsSendController {

    @Autowired
    private SmsComponent smsComponent;

    /**
     * 备注：
     * 该服务提供是由别的服务调用的，而不是页面直接调用的。所以添加@GetMapping做请求路径处理
     */
    @GetMapping
    public R sendCode(@RequestParam("phone") String phoneNumber, @RequestParam("content") String content){
        smsComponent.sendSmsCode(phoneNumber,content);
        return R.ok();
    }
}
```

+ 认证中心模块做验证码发送功能

  【gulimall-auth-server】

① 创建LoginController.java接受”发送验证码“请求

```java
@ResponseBody
@GetMapping("/sms/sendCode")
public R sendCode(@RequestParam("phone") String phoneNumber){
    //随机验证码
    String substring = UUID.randomUUID().toString().substring(0, 5);
  thirdPartFeignService.sendCode(phoneNumber,"code:"+substring);
    return R.ok();
}
```

② 引入Feign远程调用依赖，并且在主程序中`@EnableFeignClients`启用feign

③ 创建feign，向`gulimall-thirty-part`发送请求服务

```java
@FeignClient("gulimall-third-party")    //通过feign调用第三方服务
public interface ThirdPartFeignService {

    @GetMapping("/sms/sendCode")
    public R sendCode(@RequestParam("phone") String phoneNumber, @RequestParam("content") String content);
}
```

④ 配置页面发送的请求参数，基本的请求格式：`http://http://auth.gulimall.com/sms/sendCode?phone=`

#### 验证码接口防刷

<font color=red>需求描述:</font>

在”注册页面“的”发送验证码“功能中，虽然有倒计时机制，但是重要通过刷新页面，就可以做验证码发送。且通过控制台可以查看到源码中发送的请求地址，这里存在验证码接口被恶意消耗的可能。【验证码频率，恶意刷验证码接口】

<font color=green>解决思路:</font>

① 关于刷新页面，验证码频率问题。可以设置redis校验时间，【redis中key为手机号，同个手机号需要超过指定时间才能再次发送】

```java
//LoginController.java
public R sendCode(@RequestParam("phone") String phoneNumber){
 //TODO 1.接口防刷
 //1.1验证码频率
        String redisKey = redisTemplate.opsForValue().get(AuthServerConstant.SMS_CODE_CACHE_PREFIX + phoneNumber);
        if(!StringUtils.isEmpty(redisKey)){
            long l = Long.parseLong(redisKey.split("_")[1]);
            //系统为毫秒单位
            if(System.currentTimeMillis()-l <60*1000){
                //60秒内不能再发
                return R.error(BizCodeEnume.SMS_CODE_EXCEPTION.getCode(), BizCodeEnume.SMS_CODE_EXCEPTION.getMsg());
            }
        }}
```

补充枚举SMS_CODE_EXCEPTION

```java
//BizCodeEnume
SMS_CODE_EXCEPTION(10002, "验证码获取频率太高，请稍后再发送"),
```

前端回调

```js
//发送验证码
$(function (){
   $("#sendCode").click(function (){
      //2.启动倒计时功能
      if($(this).hasClass("disabled")){
         //正在倒计时中

      }else{
         //1.给指定手机发送验证码
         $.get("/sms/sendCode?phone="+$("#phoneNumber").val(),function (data){
            if(data.code !=0){
               //60s内只允许获取一次验证码
               alert(data.msg);
            }
         })
         timeoutChangeStyle();
      }
   });
});
```

② 接口防刷

//TODO





#### 验证码校验

思路：后台在接收到验证码请求后，在redis中临时存储验证码，后续再与用户的验证码请求进行校验。

① auth模块引入redis依赖，配置redis地址

② LoginController.java处理业务逻辑

```java
 public R sendCode(@RequestParam("phone") String phoneNumber){ 
     //随机验证码
        String substring = "code:"+UUID.randomUUID().toString().substring(0, 5);
     //redis：key-phone,value-code 格式【sms:code:159xxxx123->123】
    //key:前缀+手机号，value:验证码，消亡时间，时间单位
redisTemplate.opsForValue().set(AuthServerConstant.SMS_CODE_CACHE_PREFIX+phoneNumber,substring,10, TimeUnit.MINUTES);
      thirdPartFeignService.sendCode(phoneNumber,substring);
        return R.ok();
 }
```

> SMS_CODE_CACHE_PREFIX是常用值，放在common模块，不设置问题也不大

### 注册功能

+ 创建VO，做校验

  ```java
  @Data
  public class UserRegistVo {
  
      @NotEmpty(message = "用户名必须提交")
      @Length(min = 6,max = 18,message = "用户名必须是6-18位")
      private String userName;
      @NotEmpty(message = "密码不能为空")
      @Length(min = 6,max = 18,message = "密码必须是6-18位")
      private String passWord;
      //正则表达式：不能为空^，第一位是1，第二位是3-9，剩下的是0-9且必须有9个
      @Pattern(regexp = "^[1]([3-9])[0-9]{9}$/",message = "手机号格式不正确")
      @NotEmpty(message = "手机号不能为空")
      private String phone;
      @NotEmpty(message = "验证码不能为空")
      private String code;
  }
  ```

+ 处理校验
  内置对象：BindingResult搭配@Valid做校验；RedirectAttributes处理重定向无法接收post请求

```java
//LoginController.java   
/** 重定向携带数据。利用session原理。将数据放在session中。只要跳到下一个页面取出这个数据以后，session里面的数据就会删掉
**/
    // TODO【分布式情况下，session会存在问题】
    @PostMapping("/register")
    public String register(@Valid UserRegistVo userRegistVo, BindingResult result, RedirectAttributes redirectAttributes){
//BindingResult:持有验证运行的结果，也就是配合着@Valid注解校验bean的结果
        if(result.hasErrors()){
            Map<String, String> errors = result.getFieldErrors().stream().collect(Collectors.toMap(FieldError::getField, FieldError::getDefaultMessage));
//            model.addAttribute("errors",errors);
            redirectAttributes.addFlashAttribute("errors",errors);
             //return "register";      //转发模式，会自行拼串前后缀,由thymeleaf重新渲染 【会产生的问题：刷新页面导致模板重复提交】
            //重定向模式转发，【前端发送的服务是post，而register.html页面是转发后接收的页面，这里默认只是支持get【重定向不会携带数据，即post】，会产生的问题是： Request method 'POST' not supported】
            return "redirect:http://auth.gulimall.com/register.html";
        }

        //注册成功回登录页
            //由于config包映射了login.html的地址，所以这里返回不需要用全路径：http://auth.gulimall.com/login.html
        return "redirect:/login.html";
    }
```

+ 页面渲染

  ```html
  <div class="tips" style="color: red" th:text="${errors!=null?(#maps.containsKey(errors,'userName')?errors.userName:''):''}">
  ```

+ 证码注册

  （前面已经完成了验证码发送、接收、后台redis处理校验逻辑）

  ---- 注册功能由gulimall-member完成，需要进行远程调用

  ① 调用远程服务gulimall-member

  ```java
  @FeignClient("gulimall-member")
  public interface MemberFeignService {
  
      @PostMapping("member/member/register")
       R register(@RequestBody UserRegistVo userRegistVo);
  }
  ```

  ② gulimall-member做注册功能接口

  ```java
  /**
   * 会员注册功能
   */
  @PostMapping("/register")
  public R register(@RequestBody MemberRegisterVo memberRegisterVo){
  
      try {
          memberService.register(memberRegisterVo);
      }catch (PhoneExistException e){
          return R.error(BizCodeEnume.PHONE_EXIST_EXCEPTION.getCode(),BizCodeEnume.PHONE_EXIST_EXCEPTION.getMsg());
      }catch (UserNameExistException e){
          return R.error(BizCodeEnume.USER_EXIST_EXCEPTION.getCode(),BizCodeEnume.USER_EXIST_EXCEPTION.getMsg());
      }
  
      return R.ok();
  }
  ```

```java
 @Override
    public void register(MemberRegisterVo memberRegisterVo) {

        MemberEntity memberEntity = new MemberEntity();
        MemberDao memberDao = this.baseMapper;

        //设置默认等级
        MemberLevelEntity memberLevelEntity = memberLevelDao.getDefaultLevel();
        memberEntity.setLevelId(memberLevelEntity.getId());
        //检查用户名和手机号是否唯一。目的让controller能感知异常，异常机制
        checkPhoneUnique(memberRegisterVo.getPhone());
        checkUserNameUnique(memberRegisterVo.getUserName());

        //设置手机号
        memberEntity.setMobile(memberRegisterVo.getPhone());
        //设置用户名
        memberEntity.setUsername(memberRegisterVo.getUserName());
        //设置密码 【数据库存储密码要进行加密处理】
        BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
        memberEntity.setPassword(passwordEncoder.encode(memberRegisterVo.getPassWord()));
        //其他的默认信息

        memberDao.insert(memberEntity);
    }

    @Override
    public void checkPhoneUnique(String phone) throws PhoneExistException{
        MemberDao memberDao = this.baseMapper;
        Long mobile = memberDao.selectCount(new QueryWrapper<MemberEntity>().eq("mobile", phone));
        if(mobile>0){
            throw new PhoneExistException();
        }
    }

    @Override
    public void checkUserNameUnique(String userName) throws UserNameExistException{
        MemberDao memberDao = this.baseMapper;
        Long count = memberDao.selectCount(new QueryWrapper<MemberEntity>().eq("username", userName));
        if(count>0){
           throw new UserNameExistException();
        }
    }
}
```

```xml
    <select id="getDefaultLevel" resultType="com.atguigu.gulimall.member.entity.MemberLevelEntity">
        SELECT * FROM `ums_member_level` WHERE default_status = 1;
    </select>
```



③ 远程调用成功，gulimall-auth-server.loginController进行注册功能

```java
 //调用gulimall-member模块，注册进数据库
                R register = memberFeignService.register(userRegistVo);
                if(register.getCode()==0){
                    //成功注册
                    return "redirect:http://auth.gulimall.com/login.html";
                }else {
                    Map<String, String> errors = new HashMap<>();
                    errors.put("msg",register.getData(new TypeReference<String>(){}));
                    return "redirect:http://auth.gulimall.com/register.html";
                }
```



#### 注册密码存储

<font color=orange>描述:</font>

数据库对于密码存储不能进行明文存储。要进行加密操作，加密模式分为：
可逆【通过算法可知明文】与不可逆【知道算法也推不出】

<font color=green>MD5加密算法</font>

>  说明：
>
> + MD5 (Message Digest algorithm 5 ，信息摘要算法)
>
>   + 压缩性：任意长度的数据，算出的MD5值长度都是固定的
>
>   + 容易计算：从原数据计算出MD5值很容易
>
>   + 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别
>
>   + 强抗碰撞：两个不同的数据得到相同MD5值的可能性很低
>
> + 加盐：
>   + 通过生成随机数与MD5生成字符串进行组合
>   + 数据库同时存储MD5值与salt值。验证正确性时使用salt进行MD5即可
>
> 

java的md5对象：

```java
//md5加密
DigestUtils
//md5盐值加密【逻辑类似于：“密码”+system.currentTimeMills()】
    //加盐：$1$+8位字符
Md5Crypt.md5Crypt(Bytes)
```

验证：

用户明文——>md5加密——>+数据库中查询盐值字段<——>校验

spring提供的密码加密器：

```java
//加密
BCryptPasswordEncoder.encode(rawPassWord);
//校验
BCryptPasswordEncoder.matches(rawPassWord，encodePassWord);
```







#### 补充说明

+ 重定向POST请求不被支持

```text
 Request method 'POST' not supported
```

操作：用户注册请求 ——>/regist [post方式] （路径默认都是get方式访问）

<font color=green>解决思路</font>

① 返回值给指定路径，而不是重定向。即直接通过thymeleaf直接渲染【但产生的问题是：刷新页面导致模板重复提交】
② 使用RedirectAttributes是springmvc提供的内置方法，作用：重定向视图，并且携带数据

+ 异常处理机制

<font color=orange>场景描述:</font>

方法register中，含有处理username校验的业务

方法register定义为了void类型，没有返回值。但是，在后续的业务处理中，发现需要反馈给前端错误信息。这时候，可选择异常处理机制进行替代，而不是修改方法类型。

**操作步骤：**
① 创建Exception类，作为反馈异常的信息。实现java内置对象RuntimeException作为运行时异常抛出

```java
public class UserNameExistException extends RuntimeException{

    public UserNameExistException(){
        super("用户名存在异常");
    }
}
```

② 自定义校验方法，如果产生异常则抛出以上信息

```java
@Override
    public void checkUserNameUnique(String userName) throws UserNameExistException{
        MemberDao memberDao = this.baseMapper;
        Long count = memberDao.selectCount(new QueryWrapper<MemberEntity>().eq("username", userName));
        if(count>0){
            throw new PhoneExistException();
        }
        throw new UserNameExistException();
    }
```

③ 层层往上抛，最终由controller接收并反馈给前端

```java
@PostMapping("/register")
public R register(MemberRegisterVo memberRegisterVo){

    try {
        memberService.register(memberRegisterVo);
    }catch (PhoneExistException e){
        return R.error(BizCodeEnume.PHONE_EXIST_EXCEPTION.getCode(),BizCodeEnume.PHONE_EXIST_EXCEPTION.getMsg());
    }catch (UserNameExistException){
        return R.error(BizCodeEnume.USER_EXIST_EXCEPTION.getCode(),BizCodeEnume.USER_EXIST_EXCEPTION.getMsg());
    }

    return R.ok();
}
```

补充异常信息：

common.exception.BizCodeEnume.java

```java
USER_EXIST_EXCEPTION(15001, "用户存在异常"),
PHONE_EXIST_EXCEPTION(15002, "手机号存在异常");
```

### 登录功能

#### 常规登录功能

+ 创建VO

```java
@Data
public class UserLoginVo {
    private String loginAcct;
    private String passWord;
}
```

+ 修改页面渲染

```html
<form action="/login" method="post">
    <div style="color: red" th:text="${errors!=null?(#maps.containsKey(errors,'msg')?errors.msg:''):''}"></div>
   <ul>
      <li class="top_1">
         <img src="/static/login/JD_img/user_03.png" class="err_img1" />
         <input type="text"  name="loginAcct" placeholder=" 邮箱/用户名/已验证手机" class="user" />
      </li>
      <li>
         <img src="/static/login/JD_img/user_06.png" class="err_img2" />
         <input type="password" name="passWord" placeholder=" 密码" class="password" />
      </li>
      <li class="bri">
         <a href="/static/login/index.html">忘记密码</a>
      </li>
      <li class="ent"><button class="btn2" type="submit"><a>登 &nbsp; &nbsp;录</a></button></li>
   </ul>
</form>
```

+ LoginController.java做请求接收与页面重定向

  ```java
  @PostMapping("/login")
  public String login(UserLoginVo vo,RedirectAttributes redirectAttributes){
      //远程登录
      R login = memberFeignService.login(vo);
      if(login.getCode() == 0){
          //成功，获取用户名
           MemberRespVo data = login.getData("data", new TypeReference<MemberRespVo>() {});
            session.setAttribute(AuthServerConstant.lOGIN_USER,data);
              login.getData("data",new TypeReference<MemberRespVo>(){});
          return "redirect:http://gulimall.com";
      }else {
          HashMap<String, String> errors = new HashMap<>();
          errors.put("msg",login.getData("msg",new TypeReference<String>(){}));
          redirectAttributes.addFlashAttribute("errors",errors);
          return "redirect:http://auth.gulimall.com/login.html";
      }
  }
  ```

+ Feign做远程调用

+ 远程登录功能

  ```java
  //MemberController.java 
  /**
   * 登录功能
   */
  @PostMapping("/login")
  public R login(@RequestBody MemBerLoginVo memBerLoginVo){
  
      MemberEntity entity = memberService.login(memBerLoginVo);
      if(entity!=null){
          return R.ok().setData(entity);
      }else {
       return R.error(BizCodeEnume.LOGINACCT_PASSWORD_INVAILD_EXCEPTION.getCode(), BizCodeEnume.LOGINACCT_PASSWORD_INVAILD_EXCEPTION.getMsg());
      }
  }
  ```

  ```java
  // MemberServiceImpl.java
  @Override
  public MemberEntity login(MemBerLoginVo memBerLoginVo) {
      //账号匹配【用户名&手机号】
      MemberDao memberDao = this.baseMapper;
      MemberEntity entity = memberDao.selectOne(new QueryWrapper<MemberEntity>().eq("username", memBerLoginVo.getLoginAcct()).
              or().eq("mobile", memBerLoginVo.getLoginAcct()));
      if(entity == null){
          // 登录失败
          return null;
      }else{
          //1.去数据库查询密码”加盐值“【密码存储方式：md5+盐值】,获取数据库的password
          BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
          //2.密码匹配
          boolean matches = passwordEncoder.matches(memBerLoginVo.getPassWord(), entity.getPassword());
          if(matches){
              return entity;
          }else {
              return null;
          }}}
  ```

#### 社交登录功能

> 备注：视频使用微博作为权限认证功能。目前没有微博，暂时使用gitee

[gitee_oauth2接口文档](https://gitee.com/api/v5/oauth_doc#/)

+ 业务代码

① 引入http工具类

> 为了方便发送http请求，引不引入问题不大
>
> + HttpUtils请从
>
> https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/src/main/java/com/aliyun/api/gateway/demo/util/HttpUtils.java下载
>
>
>    * 相应的依赖请参照
>
>         https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/pom.xml

② 创建OAuth2Controller做请求处理

```java
/**
 * 社交登录请求
 */
@Slf4j
@Controller
public class OAuth2Controller {

    @Autowired
    private MemberFeignService memberFeignService;

    @GetMapping("/oauth2.0/gitee/success")
    public String gitee(@RequestParam("code") String code, HttpSession session) throws Exception {
        Map<String, String> map = new HashMap();
        map.put("client_id",client_id);
        map.put("redirect_uri","http://auth.gulimall.com/oauth2.0/gitee/success");
        map.put("client_secret",client_secret);
        map.put("code",code);
        map.put("grant_type","authorization_code");
        //1.根据code换取access_token
        HttpResponse response = HttpUtils.doPost("https://gitee.com", "/oauth/token", "post",  new HashMap<>(), map, new HashMap<>());

        //2.处理响应回来的json串
        if(response.getStatusLine().getStatusCode() == 200){
            //获取access_token
            String json = EntityUtils.toString(response.getEntity());
            SocialUser socialUser = JSON.parseObject(json, SocialUser.class);
            //远程调用member服务来处理用户信息注册、校验功能
            R r = memberFeignService.oauth2Login(socialUser);
            if(r.getCode()==0){
                MemberRespVo data = r.getData("data", new TypeReference<MemberRespVo>() {
                });
                log.info("登录成功：用户信息为：{}"+data.toString());
                //第一次使用session;命令浏览器保存JSESSIONID这个cookie,以后浏览器访问哪个网站就会带上这个网站的cookie
                    //解决子域之间：gulimall.com -->auth.gulimall.com ; order.gulimall.com
                    //要求：指定域名作用为父域名，即是是子域发的JSESSIONID，父域也可以使用其cookie信息【因为涉及到tomcat发的session,很麻烦，整合springSession来处理】
                session.setAttribute("loginUser",data);
               // 登录成功就跳回首页
                return "redirect:http://gulimall.com";

            }else {
                return "redirect:http://auth.gulimall.com/login.html";
            }

        }else {
            //失败重定向到登录页
            return "redirect:http://auth.gulimall.com/login.html";
        }
    }
}
```

③ 给表usm_member添加字段`social_id`,`access_token`,`expires_in`

> 备注：正常逻辑，应该对每个授权应用做表单。但该练手项目为了避免麻烦，直接在usm_member表中添加social_id,access_token,expires_in三个字段【默认授权应用之间的用户id都不一样。】

④ 远程调用member服务，做注册/登录用户功能

```java
//MemberController.java
 /**
     * 登录功能
     * 【社交登录】
     */
    @PostMapping("/oauth2/login")
    public R oauth2Login(@RequestBody SocialUser socialUser) throws Exception {

        MemberEntity entity = memberService.login(socialUser);
        if(entity!=null){
            return R.ok().setData(entity);
        }else {
            return R.error(BizCodeEnume.LOGINACCT_PASSWORD_INVAILD_EXCEPTION.getCode(), BizCodeEnume.LOGINACCT_PASSWORD_INVAILD_EXCEPTION.getMsg());
        }
    }
```

```java
//MemberServiceImpl.java
@Override
    public MemberEntity login(SocialUser socialUser) throws Exception {
        //登录和注册合并逻辑
            //备注：视频中“微博”社交不需要Access_token也可以获取用户uid，而gitee则需要再发带token请求
        //2.1 查询当前社交用户的社交账号信息(uid,昵称，性别等)
        Map<String, String> query = new HashMap<>();
        query.put("access_token",socialUser.getAccess_token());
        HttpResponse response = HttpUtils.doGet("https://gitee.com", "/api/v5/user", "get", new HashMap<String, String>(), query);
        if(response.getStatusLine().getStatusCode() == 200){
            String json = EntityUtils.toString(response.getEntity());
            JSONObject jsonObject = JSON.parseObject(json);
            String uid = jsonObject.get("id").toString();
            //1.判断当前社交用户是否已经登陆过系统
            MemberEntity memberEntity = this.baseMapper.selectOne(new QueryWrapper<MemberEntity>().eq("social_id", uid));
            if(memberEntity !=null){
                //1.用户有注册记录,更新信息
                MemberEntity updateDate = new MemberEntity();
                updateDate.setId(memberEntity.getId());
                updateDate.setAccessToken(socialUser.getAccess_token());
                updateDate.setExpiresIn(socialUser.getExpires_in());
                //...其他的不重要，更不更新无所谓
                memberDao.updateById(updateDate);

                memberEntity.setAccessToken(socialUser.getAccess_token());
                memberEntity.setExpiresIn(socialUser.getExpires_in());
                return memberEntity;
            }else{
                //2.没有查到当前社交用户记录，就需要注册一个
                MemberEntity register = new MemberEntity();
                try{
                        String name = jsonObject.get("name").toString();
                        String email = jsonObject.get("email").toString();
                        String socialId = jsonObject.get("id").toString();
                    //.....等等信息
                        register.setNickname(name);
                        register.setEmail(email);
                        register.setSocialId(socialId);
                }catch (Exception e){
                    /**
                     * 远程查询昵称这些不重要的，即是出现问题也可以忽略
                     */
                }
                register.setAccessToken(socialUser.getAccess_token());
                register.setExpiresIn(socialUser.getExpires_in());
                memberDao.insert(register);
                return register;
            }
        }else {
            throw new AccessTokenException(response.getStatusLine().getStatusCode(),response.getStatusLine().getReasonPhrase());
        }

    }

```

⑤ 页面渲染，发送请求

```html
<li>
   <a href="https://gitee.com/oauth/authorize?client_id={gitee提供的client_id}
   &redirect_uri=http://auth.gulimall.com/oauth2.0/gitee/success&response_type=code">
      <img style="height: 18px;width: 18px" src="/static/login/JD_img/gitee-log.png" />
      <span>gitee</span>
   </a>
</li>
```



### SpringSession整合

[spring官方文档](https://docs.spring.io/spring-session/reference/3.0/samples.html)

#### 环境配置

> :exclamation: 注意：无论子域服务还是父域服务，对于“环境配置”、"自定义SpringSession"都要做一遍。即auth-server服务要做以下环境配置，product服务也要做以下环境配置

+ 引入依赖

  ```xml
  <dependency>
  		<groupId>org.springframework.session</groupId>
  		<artifactId>spring-session-data-redis</artifactId>
  </dependency>
  ```

+ 配置redis控制session

  详细查看文档

  + 必须配置，可选择redis、mongodb......等

  ```properties
  spring.session.store-type=redis # 设置redis存储session
  ```

  + 选择配置

    ```properties
    server.servlet.session.timeout=30  # session过期时间
    spring.session.redis.flush-mode=on_save # 刷新模式
    spring.session.redis.namespace=spring:session # 存储会话的命名空间
    ```

+ 配置redis连接

+ 主程序开启session-redis服务`@EnableRedisHttpSession `

#### 自定义SpringSession

> :exclamation:  存在两种问题，需要进行自定义化SpringSession :
>
> ① 默认发的令牌，作用域只是作用于当前域（即下面附录中Session共享问题的①）
>
> ② 使用JSON的序列化方式来序列化对象数据到redis中，方便观察

+ 通过暴露CookieSerializer，修改session的作用域

  + 说明：session在服务间传输是存放在cookie中，所以可以在auth-server服务重定向到product服务前，将Cookie序列化器提前暴露从而操作session的`domain`

    ```java
    package com.atguigu.gulimall.auth.config;
    @Configuration
    public class GulimallSessionConfig {
        @Bean
        public CookieSerializer cookieSerializer(){
            DefaultCookieSerializer cookieSerializer = new DefaultCookieSerializer();
    
            //放大子域的作用域
            cookieSerializer.setDomainName(".gulimall.com");
            //修改session名
            cookieSerializer.setCookieName("GULISESSION");
            return cookieSerializer;
        }
    ```

+ spring提供了redis序列化器

  + 说明：在[官方源码中](https://github.com/spring-projects/spring-session/blob/3.0.3/spring-session-samples/spring-session-sample-boot-redis-json/src/main/java/sample/config/SessionConfig.java)演示了config是通过`RedisSerializer` bean来改变存储数据的json序列化

    ```java
    package com.atguigu.gulimall.auth.config;
    @Configuration
    public class GulimallSessionConfig {
        @Bean
    public RedisSerializer<Object> springSessionDefaultRedisSerializer() {
       return new GenericJackson2JsonRedisSerializer();
    }
    }
    ```

## 附录

### OAuth2

简介：对于用户相关的OpenAPI（例如获取用户信息、动态同步、照片、日志、分享等），为了保护数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权。

oauth2认证流程：
![AOuth2认证流程](../image/AOuth2认证流程.png)

### Session共享问题-session原理

seesion原理：
session是一种记录浏览器状态的机制。与cookie的区别在于，session是保存在服务器的内存中，cookie是保存在浏览器的内存中。

**<font color=red>问题描述：</font>**

分布式情况下，session会产生两种问题：

①域名不同，服务不同，session无法共享（子域共享问题）

> 场景描述：auth.gulimall.com/login.html发送社交登录请求，成功后跳转的页面为gulimall.com。域名改变，导致session无法共享

② 复制多份服务，同个域名下session不同步的问题

> 场景描述：同个域名，在分布式下，A服务复制多份（集群），B,C,D........ ，无同步到session信息，导致请求进来时，A服务存储了session了，而B其他服务没有

**<font color=green>解决方案：</font>**

针对问题① ，解决方案有：

+ 放大域名的作用域的范围

  + 例如：auth.gulimall.com发送的授权登录请求，成功后跳转到gulimall.com。在cookie 中可以查看到auth.gulimall.com的JSESSIONID作用域只是限于自身，可修改重定向后域名的作用域范围为*.gulimall.com

  > 备注：JSESSIONID即session，tomcat发的session都命名为JSESSIONID

  + 解决方案：
    因为第一次登录的session是由tomcat发的，而默认的作用域就是该域域名，修改起逻辑很麻烦，建议使用springSession框架整合处理。

针对问题②，解决方案有：

+ hash一致性

  + 特点：在负载均衡（nginx）中设置hash值，当同个用户访问，就通过hash值定点该用户只能访问某服务（存有该用户session的服务）

  + 使用操作方案：

    + 方案1：负载均衡服务做hash值分配 【四层业务代理ip_hash方案】

    + 方案2：浏览器端分配session识别的id，再通过id在负载均衡服务中进行分配服务 【七层代理ip_hash方案】

      > 备注：**四层**是指传输层，**七层**是指应用层。
      > **四层**：根据用户ip+port来做hash
      >
      > **七层**：根据http协议中的某些属性来做hash（一般就URL的信息）

  + 优点：

    + 只需要改nginx配置，不需要修改应用代码
    + 负载均衡，只要hash属性的值分布式是均匀的，多台web-server的负载是均衡的
    + 可以支持web-server水平扩展（相比session同步而言）

  + 缺点：

    + session还是存在web-server中的，所以web-server重启或宕机等情况还是会导致部分session丢失，影响部分用户体验
    + 如果web-server水平扩展，rehash后session重新分布，也会有一部分用户路由到不正确的服务中（不是存储该用户session的服务）

  + 但是，以上缺点问题也不是很大，因为session本身是有有效期限，所以这种方案可以使用

+ 统一存储

  + 特点：无论哪个服务器，都统一存储在一个地方【DB，redis等等】，一般存储在redis
  + 优点：
    + 可以水平扩展，数据库/缓存水平切分即可
    + web-server重启、扩容都不会导致session丢失
  + 不足：
    + 增加了一次网络调用，并且需要修改应用代码【如将所有的getSession方法替换为从Redis查数据的方式，java的`StandardSession类`默认是从内存中获取session的】
    + redis获取数据比直接在内存中获取要慢，且中间隔着redis，还要增加网络交互的过程
  + 补充：针对上述不足，SpringSession是一种解决方案。

### SpringSession核心原理

@EnableRedisHttpSession 导入 RedisHttpSessionConfiguration 配置

1. 给容器中添加了一个组件

   RedisOperationsSessionRepository : redis操作session。session的增删改查

2. 
