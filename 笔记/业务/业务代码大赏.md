# 业务代码大赏

## 一、知新而改

### 保存属性同时保存属性关联

+ 场景描述：

> 假设有 `品牌信息表` & `品牌分组关系表`（可以理解成:品牌分组关系表 的逻辑外键是 品牌信息表 id）  
> 要求：发送一堆数据进行保存（品牌分组关系表 & 品牌信息 的属性）进行关联保存保存 【两张表的主键都是自增，而品牌关系表中存在品牌信息表id字段】

+ 曾经错误做法：

> ① 保存品牌表信息，② 然后再查询品牌表id，③ 最后发给品牌分组关系表实体setter,最后统一该表所有信息插入

+ 新想法：

> 原来，mybatisplus的save方法是有返回值的，也就是会自动把自增表的id返回，直接接收品牌id并且统一插入品牌分组关系表

```java

 @Autowired
private AttrAttrgroupRelationDao attrAttrgroupRelationDao;

    /**
     * 业务逻辑：
     * ① 保存基本信息
     * ② 保存关联的分组信息
     * @param attr
     */
    public void saveAttr(AttrVo attr) {
        AttrEntity attrEntity = new AttrEntity();
//        attrEntity.setAttrName(attr.getAttrName());
        //spring提供了BeanUtils，可以对应属性名封装信息
        BeanUtils.copyProperties(attr,attrEntity);
        // 1.保存基本信息,并且数据库返回attr_id
        this.save(attrEntity);
        // 2.保存关联关系
        AttrAttrgroupRelationEntity relationEntity = new AttrAttrgroupRelationEntity();
                // 主要接收属性id和属性分组id
        relationEntity.setAttrId(attrEntity.getAttrId());
        relationEntity.setAttrGroupId(attr.getAttrGroupId());
        attrAttrgroupRelationDao.insert(relationEntity);
    }
```

涉及到的类包：AttrController.java ; AttrServiceImpl.java ; AttrVo.java 视频集数：p76

### 不同的请求url访问同一个方法

+ 场景描述:

> 在”谷粒商城项目“中，”规格参数“和”销售属性“都要存储在同一张库表中;
> 为了代码简洁和方便，后端代码设计为：增加一个判断条件用于区分是“基本属性”还是“销售属性”的请求。

<img src="./image/%E8%A7%84%E6%A0%BC%E5%8F%82%E6%95%B0%E6%A8%A1%E5%9D%97%E5%92%8C%E9%94%80%E5%94%AE%E5%B1%9E%E6%80%A7%E6%A8%A1%E5%9D%97.png" alt="规格参数模块和销售属性模块" style="zoom:80%;"/>

+ 之前做法:

> “销售属性”在发送请求的时候，携带一个参数传递给后端判断

+ 新想法:

> 可以修改controller的requestMapping，让接收的url为动态获取，这样就能自动区分到是否为“基本属性”发送的请求

+ 接口:

> 规格参数：api/product/attr/base/list/   
> 销售属性：api/product/attr/sale/list/

<font color=red>代码演示:</font>

```java
/**
 * controller接收的url为动态
 */
    @RequestMapping(value = "/{attrType}/list/{catelogId}",method = RequestMethod.GET)
    public R baseAttrList(@RequestParam Map<String,Object> params,
                          @PathVariable("catelogId") Long catelogId,
                          @PathVariable("attrType")String type){
        PageUtils page = attrService.queryBaseAttrPage(params,catelogId,type);
        return R.ok().put("page",page);

    }

```

```java
 /**
     * 属性-规格参数&销售属性：列表查询&模糊列表查询
     */
    @Override
    public PageUtils queryBaseAttrPage(Map<String, Object> params, Long catelogId, String type) {
        // String.equalsIgnoreCase(param)忽略大小写,String == param?true:false
        QueryWrapper<AttrEntity> queryWrapper =new QueryWrapper<AttrEntity>().eq("attr_type","base".equalsIgnoreCase(type)?1:0);
        if(catelogId != 0){
            queryWrapper.eq("catelog_id",catelogId);
        }
        String key = (String) params.get("key");
        if(!StringUtils.isEmpty(key)){
            // 检索值 attr_id,attr_name
            queryWrapper.and((item)->{
                item.eq("attr_id",key).or().like("attr_name",key);
            });
        }
        IPage<AttrEntity> page = this.page(
                new Query<AttrEntity>().getPage(params),        // 查出属性基本信息
                queryWrapper        // 模糊查询下
        );
        PageUtils pageUtils = new PageUtils(page);
        List<AttrEntity> records = page.getRecords();
        List<AttrRespVo> resopnVo = records.stream().map((attrEntity) -> {
            AttrRespVo attrRespVo = new AttrRespVo();
            BeanUtils.copyProperties(attrEntity, attrRespVo);
            //1.设置分类和分组的名字
        if("base".equals(type)){
            AttrAttrgroupRelationEntity attrId=attrAttrgroupRelationDao.selectOne(new QueryWrapper<AttrAttrgroupRelationEntity>().eq("attr_id",attrEntity.getAttrId()));
            if(attrId!=null){
                AttrGroupEntity attrGroupEntity=attrGroupDao.selectById(attrId.getAttrGroupId());
                attrRespVo.setGroupName(attrGroupEntity.getAttrGroupName());
            }
        }
            CategoryEntity categoryEntity = categoryDao.selectById(attrEntity.getCatelogId());
            if (categoryEntity != null) {
                attrRespVo.setCatelogName(categoryEntity.getName());
            }
            return attrRespVo;
        }).collect(Collectors.toList());

        pageUtils.setList(resopnVo);
        return pageUtils;

    }

```

说明:
` .eq("attr_type","base".equalsIgnoreCase(type)?1:0)`  
就是格外增加的`基本属性`查询和判断条件
> 备注：attr_type是AttrEntity的int字段，0代表销售属性，1代表基本属性

涉及类包:
> AttrController.java;</br>
> AttrServiceImpl.java

视频集数：p79

## 二、约定大于配置

### 目录布局

+ VO作用：
  > 概念上:是与前端传值交互  
  > 实际意义：①统一管理字段，避免魔法值(数据库修改了字段，无需再在项目上逐个字段修改).②作为entity的一种补充

+ TO作用：

> 概念：在springCloud中，A服务要向B服务传输数据，会将数据封装为对象，然后springCloud默认将该对象以json形式传输到B，B可逆转为对象或再传输，整个模型称为TO  
> A服务要传输，B服务要接收，两边都要有TO的包。所以一般会以第三方通用的形式呈现该传输对象（eg:gulimall-common.TO）。  
> （备注:只要json数据模型是兼容的，双方服务无需使用同一个TO，详情看`product.feign.CouponFeignService.java`的写法）


